# Zhdanovich Valery
# Date: 17/03/2024
# Description: Homework 3
# Grodno IT Academy Python 3.9.6

def pairs(numbers_string):
    #Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу.
    #Считается, что любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать.
    #Входные данные - строка из чисел, разделенная пробелами.
    #Выходные данные - количество пар.
    #Важно: `1 1 1` - это 3 пары, `1 1 1 1` - это 6 пар.

    # Преподаватель: Обработка пустой строки: "".split() вернет [''], map(int, ['']) вызовет ValueError.
    # Преподаватель: Лучше добавить проверку if not numbers_string: return 0
    # Преподаватель: Или использовать numbers = [int(x) for x in numbers_string.split() if x]
    if not numbers_string.strip(): # Преподаватель: Добавлена проверка на пустую или содержащую только пробелы строку
        return 0
    numbers = list(map(int, numbers_string.split())) # Преобразуем строку с числами в список целых чисел
    pairs = 0 # Инициализируем счетчик пар
    nums_pairs = {} # Словарь для хранения количества вхождений каждого числа

    # Преподаватель: Интересный подход к подсчету пар без использования collections.Counter или формулы n*(n-1)/2.
    # Преподаватель: Логика верная: каждая новая встреча числа `num` образует пару с каждым из уже встреченных `num`.
    for num in numbers:
        if num in nums_pairs: # Проверяем, есть ли число уже в словаре
            pairs += nums_pairs[num] # Если есть, добавляем к количеству пар количество текущих вхождений числа
            nums_pairs[num] += 1
        else:
            nums_pairs[num] = 1 # Если числа нет в словаре, добавляем его с количеством 1
    return pairs
    # Преподаватель: Алгоритм корректен и проходит тесты после добавления проверки на пустую строку.


def uniques(array):
    #Дан список. Выведите те его элементы, которые встречаются в списке только один раз.
    #Элементы нужно выводить в том порядке, в котором они встречаются в списке.
    counts = {}  # Словарь для подсчета вхождений каждого элемента
    # Преподаватель: Имя переменной uniques совпадает с именем функции, лучше использовать другое имя, например, unique_elements.
    # uniques_list = [] # Преподаватель: Переименовано для ясности
    unique_elements = []  # Список для хранения уникальных элементов в нужном порядке

    # Преподаватель: Первый проход для подсчета частоты каждого элемента.
    for element in array:
        if element in counts:
            counts[element] += 1 # Если элемент уже в словаре, увеличиваем его счетчик
        else:
            counts[element] = 1 # Если новый элемент, добавляем его в словарь с счетчиком 1

    # Преподаватель: Второй проход для сбора уникальных элементов в исходном порядке.
    for element in array:
        if counts[element] == 1:
            # uniques.append(element) # Если элемент встречается только один раз, добавляем его в список уникальных
            unique_elements.append(element) # Преподаватель: Используем переименованную переменную

    # return uniques
    return unique_elements # Преподаватель: Возвращаем переименованную переменную
    # Преподаватель: Решение верное, использует два прохода, но сохраняет порядок, как и требовалось.
    # Преподаватель: Альтернатива - использовать collections.Counter и list comprehension, как в предыдущем решении, что немного компактнее.


def ordered_list(array):
    # Дан список целых чисел. Требуется переместить все ненулевые элементы в левую часть списка,
    # не меняя их порядок, а все нули - в правую часть. Порядок ненулевых элементов изменять нельзя,
    # дополнительный список использовать нельзя, задачу нужно выполнить за один проход по списку.
    # Верните полученный список.
    nonzero_index = 0  # Индекс для отслеживания позиции для следующего ненулевого элемента

    # Преподаватель: Классический алгоритм перемещения нулей в конец с сохранением порядка ненулевых элементов.
    for i in range(len(array)):
        if array[i] != 0:
            # Если текущий элемент ненулевой, перемещаем его в начало списка (в позицию nonzero_index)
            # Преподаватель: Обмен элементами гарантирует, что ненулевые элементы окажутся слева в их исходном порядке.
            array[i], array[nonzero_index] = array[nonzero_index], array[i]
            nonzero_index += 1  # Увеличиваем индекс для следующего ненулевого элемента
    return array
    # Преподаватель: Задание выполнено верно, соблюдены все условия (один проход, in-place, сохранение порядка).


def tuple_to_list(in_tuple):
    #Возмите кортеж `('a', 'b', 'c')`, И сделайте из него список.
    lst = list(in_tuple) # Преобразуем кортеж в список
    return lst
    # Преподаватель: Все верно. Стандартное преобразование типа.


def euclid(a,b):
    #Даны два натуральных числа. Вычислите их наибольший общий делитель при помощи алгоритма Евклида (мы не знаем функции и рекурсию). can't call itself
    # Преподаватель: Реализация итеративного алгоритма Евклида.
    while b != 0:
        # Преподаватель: Кортежное присваивание для одновременного обновления a и b - эффективно и по-питоновски.
        a, b = b, a % b  # Обновляем a и b
    return a  # Когда b станет равным 0, a содержит НОД
    # Преподаватель: Алгоритм реализован правильно.


#Dictionaries
def cities(input_string):
    #Дан список стран и городов каждой страны. Затем даны названия городов. Для каждого города укажите, в какой стране он находится.
    #Учтите, что бывают ситуации когда город с таким называнием бывает в разных странах (Брест есть в Беларуси и Франции).
    #Входные данные
    # ... (описание задачи) ...
    #country_map={} # Преподаватель: Закомментированная строка, лучше убрать.
    lines = input_string.split('\n') # Разбиваем входное значение на строки

    # Преподаватель: Хорошо бы добавить .strip() к input_string перед split, чтобы убрать возможные пустые строки в начале/конце.
    # lines = input_string.strip().split('\n')

    N = int(lines[0]) # Считываем количество стран

    country_map = {}  # Словарь для хранения стран и городов

    # Преподаватель: Парсинг данных о странах и городах выполнен корректно.
    for i in range(1, N + 1): # Обрабатываем информацию о странах и городах
        data = lines[i].split()
        country = data[0]
        cities = data[1:]

        # Преподаватель: Правильно используется список в качестве значения словаря для обработки городов в нескольких странах.
        for city in cities:
            if city not in country_map:
                country_map[city] = []
            country_map[city].append(country)

    M = int(lines[N + 1]) # Считываем количество запросов

    # Преподаватель: Переменная `input_string` переиспользуется для хранения результата. Это плохая практика, так как имя переменной становится неинформативным и может ввести в заблуждение. Лучше назвать `results` или `output_lines`.
    # results = [] # Преподаватель: Используем новое имя переменной
    results = [] # Результат для каждого запроса

    # Преподаватель: Обработка запросов.
    for j in range(N + 2, N + 2 + M): # Обрабатываем запросы
        city_query = lines[j].strip()
        if city_query in country_map:
            # input_string.append(' '.join(country_map[city_query]))  # Используем пробел для объединения стран
            results.append(' '.join(country_map[city_query])) # Преподаватель: Используем новое имя переменной
        else:
            # input_string.append("Unknown")  # На случай, если город не найден
            results.append("Unknown") # Преподаватель: Используем новое имя переменной. По условиям тестов, такой случай не проверяется, но обработка ненайденного города - это разумно. Однако, тесты ожидают пустую строку или конкретную страну. Вывод "Unknown" приведет к провалу тестов, если такой тест будет добавлен. В предыдущем решении добавлялась пустая строка. Формально, по тестам из условия, здесь должно быть название страны.
    # return '\n'.join(input_string)
    return '\n'.join(results) # Преподаватель: Возвращаем новое имя переменной
    # Преподаватель: Логика верная, структура данных выбрана правильно. Основное замечание - переиспользование имени переменной `input_string`.


#Sets
def languages(input_string):
    #Задачи для домашней работы
    #Языки
    # ... (описание задачи) ...
    # Преподаватель: Использование strip() здесь хорошо.
    data = input_string.strip().split('\n')

    N = int(data[0])  # Количество школьников
    index = 1
    all_languages = set()  # Языки, которые знает хотя бы один школьник
    common_languages = None  # Языки, которые знают все школьники

    # Преподаватель: Корректный парсинг данных по каждому школьнику.
    for _ in range(N):
        Mi = int(data[index])  # Количество языков i-го школьника
        index += 1

        current_languages = set() # Множество языков текущего школьника

        for _ in range(Mi):
            language = data[index].strip()
            current_languages.add(language)
            index += 1

        # Обновляем множества
        # Преподаватель: Использование update и intersection_update для множеств - эффективно и правильно.
        all_languages.update(current_languages)  # Языки, которые знает хотя бы один школьник

        if common_languages is None:
            common_languages = current_languages  # Инициализируем, если это первый школьник
        else:
            common_languages.intersection_update(current_languages)  # Пересекаем с языками текущего школьника

    # Преподаватель: Нужно обработать случай N=0, когда common_languages останется None.
    if common_languages is None:
        common_languages = set() # Преподаватель: Добавлена обработка N=0

    # Преобразуем множества в отсортированные списки
    # Преподаватель: Сортировка перед выводом - хорошо.
    common_languages_list = sorted(common_languages)  # Языки, которые знают все
    all_languages_list = sorted(all_languages)  # Языки, которые знает хотя бы один

    # Формируем результат
    # Преподаватель: Снова используется имя `input_string` для списка результатов. Лучше использовать другое имя.
    # output_lines = [] # Преподаватель: Новое имя
    output_lines = []
    # input_string.append(str(len(common_languages_list)))  # Количество языков, которые знают все
    output_lines.append(str(len(common_languages_list)))
    # input_string.extend(common_languages_list)  # Языки, которые знают все
    output_lines.extend(common_languages_list)

    # input_string.append(str(len(all_languages_list)))  # Количество языков, которые знает хотя бы один
    output_lines.append(str(len(all_languages_list)))
    # input_string.extend(all_languages_list)  # Языки, которые знает хотя бы один
    output_lines.extend(all_languages_list)

    # return '\n'.join(input_string)
    return '\n'.join(output_lines) # Преподаватель: Возвращаем новое имя переменной
    # Преподаватель: Задача решена верно с использованием множеств. Замечание по переиспользованию имени переменной.


#Generators
def list_gen(arr1, arr2):
    #Генераторы списков
    #Используйте генератор списков чтобы получить следующий: ['xy', 'xz', 'xv', 'yy', 'yz', 'yv']. из ['x','y'] & ['y','z','v']
    #пример:
    # Преподаватель: Корректное использование list comprehension для создания декартова произведения строк.
    result = [a + b for a in arr1 for b in arr2] # Генераторы списков для создания списка пар
    return result
    # Преподаватель: Все верно.


#Генераторы словарей
def dict_gen(N):
    #Создайте словарь с помощью генератора словарей, так чтобы его ключами были числа от 1 до N, а значениями кубы этих чисел.
    # Преподаватель: Корректное использование dict comprehension. Диапазон range(1, N + 1) правильный.
    result = {i: i**3 for i in range(1, N+1)} # Генератор словарей
    return result
    # Преподаватель: Все верно.

#Кортежи
def multiplication_table(N):
    #Создайте генератор, который возвращает строки таблицы умножения от 0 до заданного числа.
    # Генератор для создания таблицы умножения от 0 до N
    # Преподаватель: Функция правильно определена как генератор с использованием `yield`.
    for i in range(N + 1): # Генератор для создания таблицы умножения
        # Преподаватель: Использование generator expression внутри join - эффективно.
        yield ' '.join(str(i * j) for j in range(N + 1))
    # Преподаватель: Эти строки не нужны и некорректны для генератора, который должен просто закончить выполнение после цикла.
    # table = N
    # return table
    # Преподаватель: Убраны лишние строки после цикла. В остальном генератор реализован верно.
